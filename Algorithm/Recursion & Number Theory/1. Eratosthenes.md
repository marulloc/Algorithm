### 1.약수와 배수

약수(Divisor)

20의 약수 구하는 법 - 1부터 20까지 나눠 떨어지는 수가 20의 약수다.

### **2. 소수(Prime)** - 1과 자기자신만 약수로 갖는 수

숫자 n이 소수인지 아닌지 판별하는 법

2~n-1의 모든 수에 대해서 n이 나눠 떨어지는지 확인하고, 나눠 떨어지는 것이 하나도 없으면 소수라고 판별한다. 하나의 숫자에서는 이러한 방식이 효과적이다. 그러나 숫자가 커지고 여러개의 숫자들에 대해 소수여부를 판단해야 된다면, 이러한 방식으로는 시간복잡도를 만족하기 어렵다.

**에라토스테네스의 체**

이럴때 에라토스테네스의 알고리즘을 사용한다.

구간내의 모든 소수를 구해라 할 때 (n logN 시간복잡도)를 갖는다. 그냥 n이 소수냐? 물어보면 에라토스테니스의 체를 사용하지 말아라. 그냥 1부터 n까지 나눠보는게 빠르다.

각각의 수들에 대해 반복문을 돌며 소수인지를 판별하는 것이 아니다. 일단 모든 수가 소수라고 가정하고, 소수로 가정한 숫자들의 배수들을 구하고 (반드시 2이상의 수부터) 소수의 배수들은 소수가 아니라고 확정 짓는 방식이다.

예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19) 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17, 19, 23)

n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 수 중에서, 소수의 개수를 구하는 프로그램을 작성하시오. (n ≤ 123,456)

n이 0이면 프로그램을 종료한다.

```Python
# 2부터 n까지의 소수 여부 배열을 반환
def prime_detector(1, n):

    # 우선 모든 수가 소수일 것이라고 가정
    # 하기된 방식으로, 소수가 아닌 것들을 소거해나간다.
    isPrime = [True] * (n+1)

    # 0과 1은 소수가 될 수 없으므로 False
    isPrime[0], isPrime[1] = False, False

    for x in range(2, n+1):
        if isPrime[x]:
            # 어떤수의 배수는 절대 소수가 될 수 없음
            for i in range(2, n//2):
                isPrime[x * i] = False

    return isPrime
```
