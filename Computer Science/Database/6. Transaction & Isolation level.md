# 트랜잭션이란?

트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻한다.

- 데이터베이스의 상태를 변화시킨다는 것은 무얼 의미하는 것일까?
- 간단하게 말해서 아래의 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미한다. - SELECT - INSERT - DELETE - UPDATE
  착각하지 말아야 할 것은, 작업의 단위는 질의어 한문장이 아니라는 점이다.

작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.

게시판을 예로 들어보자.

- 게시판 사용자는 게시글을 작성하고, 올리기 버튼을 누른다. 그 후에 다시 게시판에 돌아왔을때,
- 게시판은 자신의 글이 포함된 업데이트된 게시판을 보게 된다.
- 이러한 상황을 데이터베이스 작업으로 옮기면, 사용자가 올리기 버튼을 눌렀을 시, Insert 문을 사용하여
- 사용자가 입력한 게시글의 데이터를 옮긴다. 그 후에, 게시판을 구성할 데이터를 다시 Select 하여 최신 정보로 유지한다. 여기서 작업의 단위는 insert문과 select문 둘다 를 합친것이다. 이러한 작업단위를 하나의 트랜잭션이라 한다.

관리자나 개발자가 하나의 트랜잭션 설계를 잘하는 것이 데이터를 다루는 것에 많은 이점이 있다.

<br>
<br>
<br>

### Transaction 의 Commit Rollback

- Commit

  - Commit이란 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다라는 것을 **알려주기위해 사용하는 연산**이다. 이 연산을 사용하면 수행했던 트랜잭션이 **로그에 저장**되며, 후에 Rollback 연산을 수행했었던 트랜잭션단위로 하는것을 도와준다.

- Rollback
  - Rollback이란 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 **원자성**이 깨진경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 다시 취소시킨다. 후에 사용자가 트랜잭션 처리된 단위대로 Rollback을 진행할 수도 있다.

<br>
<br>
<br>

### 트랜잭션 특징

트랜잭션의 특징은 크게 4가지로 구분된다.

- 원자성 (Atomicity)

  - 첫번째로, 원자성은 트랜잭션이 데이터베이스에 **모두 반영되던가, 아니면 전혀 반영되지 않아야 한다**는 것이다. 트랜잭션은 사람이 설계한 논리적인 작업 단위로서, 일처리는 작업단위 별로 이루어 져야 사람이 다루는데 무리가 없다.
  - 만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람은 데이터 처리 시스템을 이해하기 힘들 뿐만 아니라, 오작동 했을시 원인을 찾기가 매우 힘들어질것이다.

- 일관성 (Consistency)

  - 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다. 트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라, **처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스**로 진행된다. 이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있는 것이다.

- 독립성 (Isolation)

  - 세번째로, 독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킨다.
  - 하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.

- 지속성 (Durability)
  - 네번째로, 지속성은 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점이다.

### 트랜잭션 격리수준 Isolation level

- 동시에 여러 트랜잭션이 처리될 때 **특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지**를 결정하는 것.
- **즉, 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준을 결정하는 것**
- Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있음 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨. 레벨을 높게 조정할 수록 발생하는 비용이 증가함
  <br>

격리수준은 크게 아래의 4개로 나뉜다.
아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.

1. **READ UNCOMMITTED**

- READ UNCOMMITTED 격리수준에서는 어떤 트랜잭션의 변경내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여진다.
- 이 격리수준에서는 아래와 같은 문제가 발생할 수 있다.
  - A 트랜잭션에서 10번 사원의 나이를 27살에서 28살로 바꾸고 아직 커밋하지 않음
  - B 트랜잭션에서 10번 사원의 나이를 조회함 -> 28살이 조회됨 (이를 **더티 리드(Dirty Read)**라고 한다)
  - A 트랜잭션에서 문제가 발생해 ROLLBACK함
  - B 트랜잭션은 10번 사원이 여전히 28살이라고 생각하고 로직을 수행함
- **데이터베이스의 일관성을 유지하는 것이 불가능함(데이터의 정합성 문제)**

2. **READ COMMITTED**

- 어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
- SQL 서버가 Default로 사용하는 Isolation Level임
- **NON-REPETABLE READ 부정합 문제가 발생할 수 있다.**
  - 예를 들어 여러 트랜잭션에서 입금/출금 처리가 계속 진행되는 트랜잭션들이 있고 오늘의 입금 총 합을 보여주는 트랜잭션이 있다고하면, 총합을 계산하는 **SELECT 쿼리는 실행될 때 마다 다른 결과**값을 가져올 것이다.

3. REPEATABLE READ

   - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다. **트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함**
   - MySQL DBMS에서 기본으로 사용하고 있고, 이 격리수준에서는 NON-REPETABLE READ 부정합이 발생하지 않는다.
   - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(+커밋된) 것만 보게 된다.
   - **Update 부정합**, **phantom Read** 문제 발생

4. SERIALIZABLE
   - 격리수준이 SERIALIZABLE일 경우 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.
   - 이러한 특성 때문에 동시처리 능력이 다른 격리수준보다 떨어지고, **성능저하**가 발생하게 된다.

#### 문제점

- Dirty Read

  > 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
  > 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

- Non-Repeatable Read

  > 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

- Phantom Read

  > 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
  >
  > 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임
