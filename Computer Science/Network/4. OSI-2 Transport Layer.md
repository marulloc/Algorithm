# Transport Layer

- end to end 연결을 관리하는 계층이다.
- 전송 계층에 도달한 메시지를 App 계층으로 보내는 역할
- 데이터를 쪼개고, TCP/UDP 중 전송 프로토콜에 맞게 메세지를 만드는 역할
  멀티플렉싱: 나눠진 데이터에 헤더를 붙이고, 아래 계층에게 데이터를 내려 보내는 것<br>
  디멀티플렉싱: 도착한 데이터의 전송계층의 헤더를 분석하여, 도착해야하는 앱의 소켓으로 보내는 것

# UDP - Transport Layer Protocol

- Hand Shaking이 없어, 연결을 위한 시간이 필요 없다.
- 대신 연결이 되었는지 신뢰할 수 없다.
- UDP 프로토콜을 사용하면, 데이터그램이 독립적으로 변하여, 데이터의 도착이 비순차적이다.
  - 연결의 신뢰성 확보와, 비순차적인 데이터를 조립하는 것은, App계층에서 담당해야한다.
- 기능이 적기 때문에 Data 크기 대비 헤더의 크기가 작다.

### UDP 헤더 (8 Byte)

1. 출발지 포트 16Bit
2. 도착지 포트 16Bit
3. 데이터의 길이 16Bit (데이터와 헤더를 합친 **패킷**의 크기)
4. 체크섬 16Bit
   - UDP에서 최소한의 **신뢰성**을 위한 장치
   - Sender 측의 전송계층은 Data를 숫자로 파싱하여 Checksum에 담아 보낸다.
   - Receiver 측의 전송계층에서는, 수신된 데이터를 숫자로 파싱하여, 도착한 Checksum과 같은지 확인
   - 이때 두개의 값이 일치하지 않으면 트랜스포트 계층은 해당 데이터를 버린다.(**버리기만 한다.**)
   - 두개의 값이 일치할지라도, 완벽히 신뢰 가능한 데이터는 아니다. 숫자 값은 맞아도 데이터의 일관성을 보장할 수 없기 때문이다.

<br>

### UDP의 디멀티플렉싱

- UDP로 동작하는 App이 여러개일지라도 소켓은 하나다. (TCP는 App마다 각자의 소켓을 갖는다.)
  - 도착지의 전송계층에선, 오직 Port번호로만 소켓을 판단, Port번호만 일치하면 하나의 소켓으로 보내버린다.

<br>
<br>

# TCP - Transport Layer Protocol

- TCP 전송의 경우, 도착지의 전송계층은, 도착한 **패킷의 순서를 맞춰서** 소켓에 올려보낸다.
- 데이터의 손실이 발생하면, 재전송 요청을 보냄으로 신뢰성을 확보한다.
- 혼잡제어, 연결관리, 흐름제어 등의 서비스를 제공하는 프로토콜로 헤더가 크다.

<br>
<br>

### TCP의 신뢰성 있는 전송

1. 전송 중 비트 에러가 발생
2. 도착지에서 Checksum이 일치하지 않는다는 것을 발견
3. TCP는 재전송해야 한다는 사실을 Sender에게 알린다.
   - 이때 사용하는 것이 **ACK/NAK**
   - Receiver는 Checksum이 불일치하면 NAK를 보낸다.
   - Sender는 NAK를 받거나, 아무것도 받지 못하면 **해당 패킷을 다시 보낸다.**

<br>

##### NAK-FREE & Pipeline Protocol

NAK를 받은 Sender는 어떤 패킷이 문제인지 알 수없다.<br>
따라서 NAK를 없애자는 개선안이 등장함(**NAK Free Protocol**)

- ACK에 마지막으로 제대로 수신한 패킷의 번호를 담아보내는 방식
- ACK(0)과 ACK(1)만을 두고, 패킷이 잘 도착했으면 ACK(0)을 전송, 반대면 ACK(1)을 전송한다.
- Sender는 데이터를 보내고 ACK를 기다린다.
  그러나 패킷 하나 보내고 대기하고, 하나 보내고 대기하는 방식에, 재전송 해야하는 상황까지 발생하면 너무 비효율
  <br>

따라서, **Pipeline Protocol** 등장

- 여러 패킷을 순차적으로 일단 다 보내고, ACK가 순차적으로 오는 것을 기다리는 방식을 사용
- 따라서 **BUFFER**가 필요해졌다.
- Sender는 *버퍼에 먼저 저장*하고, *패킷을 전송*한다. ACK가 오는 패킷은 버퍼에서 날린다.
- Receiver는 App 계층에 데이터를 조립해서 보내야 하므로, 버퍼를 두고 조립을 한다.
  - 시퀀스로 잘 도착하면 해당 덩어리를 APP으로 바로 보낸다.
  - 중간에 손실된 데이터가 있으면, 제대로 된 패킷이 올 때까지, 뒤에 있어야하는 패킷들은 버퍼에 남겨둔다.
- Pipeline Protocol에는 **Go-Back-N**방식과 **Selective Repeat**방식이 있다.

<br>
<br>
<br>

### TCP 연결관리

진짜 App 계층에서 내려보낸 데이터를 보내기 전에, 연결을 설정하는 작업을 거친다.<br>
연결 설정은 **연결 요청(SYN)**와**허가 (ACK)**로 구성된다.

##### 2-Way handshaking

1. Client > Server : **SYN**(연결 요청) 전송
2. Server > Client : **ACK**(연결 허락) 전송

**TCP/IP**는 양방향 연결이다. A host가 B host에게 연결을 요청하고 허락을 받아야 하지만, B host는 A host에게 허락을 받아야 하나, 2-way에서는 그렇지 않다.

- 2-way-handshake를 한다면 클라이언트는 서버에게 연결 요청을 하고(1), 서버는 그것에 대한 응답(2)을 함으로써 연결확립이된다. 이 때 만약 서버에 들어온 연결 요청이 사실은 긴 시간지연으로 타이머를 초과해서 재전송된 요청이라면 그리고 클라이언트와 서버의 TCP 통신은 이전에 끝난 상황이라면, 해당 요청은 연결을 확립해주면 안되는 요청이다.(https://kpuls.tistory.com/90)

<br>

##### 3-way handshaking

- 따라서, 서버는 클라이언트의 연결 요청에 대해 다시 한 번 클라이언트가 가용상태(Alive)인지 확인해야한다. 그렇기 때문에 클라이언트가 서버에게 "나는 현재 가용상태이다. " 라고 다시 한 번 서버에게 응답하는 과정이 필요하다.

1. Client > Server : **SYN**(연결 요청) 전송
2. Server > Client : **SYN+ACK**(연결 요청 + 연결 허락) 전송
3. Client > Server : **ACK**(연결 허락)전송
4. 성공적으로 연결되었으니 데이터를 전송한다.

<br>
<br>
<br>

### TCP 흐름제어

흐름제어란 Sender에게 Receiver의 **버퍼 상태**를 알려주면서, 버퍼를 초과하는 상황을 예방하는 것이다.

- Receiver의 전송계층에서, App 계층으로 데이터를 올려보내려 해도, App이 바쁜 경우가 있다.
- 이때, Sender가 데이터 계속 보내게 되면, 버퍼 overflow(**패킷 드롭**)이 발생한다.
- 이것을 예방하고자 흐름제어를 한다.

1. Receiver는 자신이 지금 감당할 수 있는 버퍼 크기를 ACK에 담아 전송한다.
2. Sender는 ACK를 보고, 버퍼에 Receiver가 받을 정도의 패킷만을 담는다.
3. Sender는 App 계층의 프로그램에게, 버퍼에 담지 못한 데이터의 크기를 알려준다.

<br>
<br>
<br>

### TCP 혼잡제어

Sender는 패킷드롭이 발생하지 않는 선에서, 또한 대역폭이 허용하는 선에서,전송률을 최대로 높이려 할 것이다.<br>
Receiver가 아닌 **네트워크 상태**를 고려하여 패킷 드롭이 발생하면 속도를 늦추는 방식이다.

##### 네트워크가 혼잡해지는 사례

1. 여러 개(N)의 호스트들이 공유하는 회선이 있을 때, 회선의 대역폭(R)을 모두 사용하게 되는 순간. 모든 호스트들의 통신에서 패킷드롭이 발생하기 시작한다.
2. 패킷드롭이 발생하게 되면, host들 마다 Timeout이 빈번하게 발생하면서 네트워크 속도는 급격하게 저하된다.
3. 재전송까지 시작되면, 새로 보내는 데이터는 전달조차 되지 않을 가능성이 있다.

- 한 호스트의 속도를 줄여도, 다른 호스트가 빈 대역폭을 차지하려고 하기 때문에 혼잡제어가 불가능해진다.

##### 혼잡 제어 방식

따라서 효율이 떨어지는 순간(패킷 드롭이 발생하는 순간), 회선에 붙은 모든 호스트가 동시에 속도를 줄여야 네트워크 속도를 회복할 수 있다.

1. **끝점간 혼잡 제어**
   혼잡제어는 Transport 계층에서 하는 것이므로, host가 혼잡한 것을 알아서 깨닫고 대응하는 방식이다.
2. **네트워크 지원 혼잡 제어**
   Network 계층의 **라우터**가 끝점의 시스템에 위치한 Sender에가 데이터를 천천히 전송하라고 지시하는 것이다.

<br>
<br>

### UDP VS TCP

- TCP를 이용하는 호스트는 비슷한 속도로 회선을 이용한다.
- TCP는 속도를 점진적으로 증가하다가, 지연이 발생하면(3개의 중복 ACK가 오면 깨닫게 됨) 전송률을 급격히 감소시킨다.
- UDP는 연결을 증가시키는 대로 대역폭을 차지한다. 속도를 높이고 싶으면 UDP 연결 갯수를 늘리면 된다.
