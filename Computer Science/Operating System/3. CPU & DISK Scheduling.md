# CPU Scheduling

CPU 스케쥴링 방식 또한 크게 두가지로 나뉜다.

1. 비선점 nonpreemtive
   프로세스 종료, I/O 이벤트 발생 전까지 현재 CPU를 잡고 있는 프로세스의 실행을 보장시켜주는 방식
2. 선점 preemtive
   OS가 로직에 따라, 임의 프로세스에 CPU를 할당해주는 방식, 즉 한 프로세스가 CPU를 선점할 수 있는 방식

#### 비선점 스케쥴링 방식의 종류

1. FCFS (First Come Frist Served)
   대기 큐에 도착한 순서대로 CPU가 할당된다.

   - **실행 시간이 짧은 프로세스가 뒤에 오는 경우가 많아지면 평균 대기시간이 길어진다.**

2. SJF (Shortest Job First)
   수행시간이 가장 짧다고 판단되는 작업을 먼저 수행. 평균 대기시간이 줄어들고, 더 많은 프로세스를 완료시키려는 방식이라 생각하면 된다.

   - **무한 연기**가 발생할 수 있다.
     - 따라서 **aging 기법**이나, **HRN**을 사용한다.

3. HRN (Highest Response-ratio Next)
   SJF에 대기시간까지 고려한 것으로, 대기시간이 긴 프로세스에게 우선순위를 준다고 생각하면된다.
   - 우선순위 계산식 = (대기시간 + 서비스시간) / 서비스시간

#### 선점 스케쥴링 방식의 종류

1. Priority Scheduling (우선순위 스케쥴링)
   대기 큐에 있는 프로세스들에게 우선순위를 부여하고, 우선순위 순으로 CPU를 사용하게 된다.

   - 우선순위는 계속 변경되는데, 그에 따라 애초에 우선순위가 낮은 프로세스의 **기아 Starvation문제**가 발생할 수 있다.

2. RR (Round Robin)
   CPU 사용시간의 limit(Time slice)을 걸어두는 로직으로 모든 프로세스가 Time slice만큼의 CPU 사용시간을 보장받게 된다.
   - **Time Slice를 프로세스의 평균 수행시간보다 짧게 잡으면 빈번한 Context Switch로 오버헤드 증가한다.**
   - **Time Slice를 너무 크게 잡으면, FCFS와 다름 없어진다.**

<br>
<br>
<br>

# DISK Scheduling

사용할 데이터가 디스크상의 여러 곳에 산재해 있는 경우, 데이터를 처리하기 위해 디스크 헤드가 움직이는 경로를 결정하는 기법

#### 용어

- Seek Time: 하드디스크의 arm을 원하는 track으로 움직이는 시간
- Rotatinal Time: arm을 트랙으로 옮긴 후, 읽으려는 데이터가 있는 sector가 회전하여 돌아올 때 까지 기다리는 시간

1. FCFS (Fist Come First Served)
   FIFO로 동작하여, 가장 공평하다.

   - **Seek Time**이 가장 크다.

2. SSTF (Shortest Seek Time First)
   **헤드**의 현재 위치에서, 가장 **가까운 섹터** 먼저 읽는다. 따라서 **암**의 이동 거리가 최소화 된다.(Seek Time 최소화)

   - 역시, **Starvation** 문제 발생 가능

3. SCAN
   끝에서 끝으로 이동하면서 섹터를 탐색한다. 끝과 끝을 왕복운동 한다고 생각하면 됨

   - 양 끝에 있는 섹터들은 서비스 횟수가 적어진다.

4. C-SCAN
   SCAN이 왕복운동 하면서 탐색을 했다면, C-SCAN은 왼쪽 끝에서 오른쪽 끝으로 이동하면서 탐색을 하고, 돌아오면서 탐색을 하지 않는 방식이다.
   - 공평함을 위해
