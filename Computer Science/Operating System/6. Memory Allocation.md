# Memory Allocation

프로그램이 메모리에 로드될 때, 통으로 올라오는 것이 아니라, 분리되서 메모리에 로드된다. <br>
이때, 분리된 조각들을 연속적으로 배치하냐, 아니면 로직에 맞게 임의에 배치하냐로 메모리 할당 방식이 크게 두가지로 나뉜다.

### 연속 메모리 할당

초기 컴퓨터 시스템에서의 연속 메모리 할당이 아니라, <br>
다중 프로그래밍 시스템에서의 연속 메모리 할당만을 다룬다.<br>

- 프로그램을 구성하는 프로세스가, 연속된 공간에 할당된다.
- 메모리에 프로그램 전체가 통으로 올라간야만 실행이 가능하다.

<br>

1. 고정 분할 방법

   - 메모리를 (**Partition**)을 둬서 고정된 크기로 분할한다.
   - 분할된 공간에는 하나의 프로세스만이 담길 수 있다.
   - 프로그램 크기에 상관 없이 빈 파티션에 프로그램을 적재한다.
   - Partition 보다 큰 작업이 있으면 **내부 단편화**가 발생한다.
     <br>

2. 가변 분할 방법

   - 고정된 크기를 사용하지 않고, 프로세스가 필요한 만큼 메모리를 할당해 주는 것이다.
   - 프로세스가 완료되고 메모리를 반납하게 되는 것이 반복되면, 사용 가능한 빈 메모리 공간이 흩어져 있게 된다. 이때, 새로 메모리를 받아야 하는 프로세스가 어느 공간에 할당되어야 할 지 결정하는 로직이 있다.
     - **최초 적합**
       프로세스를 사용 가능한 공간 중 제일 처음에 있는 공간에 할당
     - **최적 적합**
       사용 가능한 공간 중, 제일 딱 맞는 공간에 할당(즉, 사용 가능하면서 제일 작은 공간에 할당)
     - **최악 적합**
       가장 큰 공간에 할당한다.
   - 최대한 알맞는 공간에 프로세스를 적합하는 것을 반복하다보면, 메모리 공간 남아있는데, 다른 프로세스가 할당 될 수 없는 상황 **외부 단편화**가 발생한다.
     - **메모리 통합**
       작업이 끝나고 메모리가 반납되었을 때, 인접한 다른 빈 공간과 메모리를 통합해서 외부 단편화를 해결한다.
     - **메모리 압축**
       메모리를 사용하고 있는 프로세스들을 움직여서, 사용 가능 공간을 하나의 큰 브록으로 만듦으로 외부 단편화를 해결한다.

<br>
<br>
<br>

### 분산 메모리 할당

프로그램의 조각들이 여러 물리적 주소에 분산되어 있는 것이다.

- 프로그램을 **세그먼트**나 **페이지** 단위로 분리하고 임의의 공간에 할당된다.
- 프로그램 전체가 로드되지 않아도, 실행이 가능하다.

1. **Paging**(고정 분할)

   - 물리적 주소, 메모리를 **page**라는 고정된 크기로 분할한다. 이때 메모리의 각 구역을 **프레임**이라고 부른다.
   - **프로그램**또한 **Page**로 분할한다.
     프로그램의 page는 논리적 주소를 가지기 때문에, 실제 물리 주소를 할당한 후 접근하기 위해, **page table**을 필요로 한다.(프로그램의 page가 메모리의 어느 page에 위치해 있는지 명시하는 테이블)
     - 직접 매핑
     - 연관 매핑
     - 연관 직접 매핑
   - 프로그램의 마지막 page는, 지정한 page의 크기보다 작을 수 있기 때문에, **내부단편화**가 일어난다.

2. **Segmentation**(가변 분할)
   - 페이징은 프로세스를 물리적 단위인 페이지로 분할하여 적재하는 방법이다. 즉 프로세스를 일정하게 앞에서 뒤로 자르는 방식이다.
   - segmentation은 프로세스를 논리적 단위인 **segment**로 자른다. 즉, 의미로 분할한다. 우리가 함수를 나누듯, segmentation은 **쓰임새에 맞게 분할**한다.
   - 따라서 각 segment의 크기는 다르다.
   - segment의 크기는 가변적이기 때문에, **외부 단편화**가 발생할 수 있다.

##### segmentation이 효율적이지만, 외부 단편화가 발생할 여지가 있는 단점이 있다. 외부 단편화의 오버헤드는 치명적이므로 _페이지화된 세그멘테이션_ 이라는 기법이 등장했다.
