# 렉시컬 환경 컴포넌트와 변수 환경 컴포넌트

#### 실행컨텍스트의 구성

```javascript
실행컨텍스트_EC : {
    렉시컬환경컴포넌트_LEC : { },
    변수환경컴포넌트_VEC : { },
    This바인딩컴포넌트_TBC : { }
}
```

<br>

# 렉시컬 환경 컴포넌트

- 함수와 변수의 식별자 해결을 위한 환경을 설정하는 공간
- 함수 초기화 단계에서 해석한 함수와 변수가 렉시컬 환경 컴포넌트에 저장된다.
  - 함수 내부의 변수와 함수가 `{name : value}`형태로 저장된다.
    - 변수는 `{변수명 : undefined}` 로 저장되며
    - 함수선언문은 `{함수이름 : function object}` 로 저장된다.
  - 엔진은 이름으로 함수와 변수를 검색할 수 있다.(Identifier Resolution이 가능하다)
- 또한, 함수 바깥에 위치한 함수와 변수를 사용할 수 있도록 참조 환경을 설정한다.
  - 즉, 함수의 Scope가 렉시컬 환경 컴포넌트에 설정된다. 다시 말해, 함수가 속한 Object의 환경이 설정되는 공간이 존재한다.

#### 이렇게 함수 내부에 있는 것과 함수 안에 있는 것이 렉시컬 환경 컴포넌트에 설정된다. 즉 하나의 Context가 된다.

<br>
<br>

### 렉시컬 환경 컴포넌트 구성

```Javascript
렉시컬환경컴포넌트_LEC : {
    환경레코드_ER : { point : 100 },
    외부렉시컬환경참조_OLER : {
        title: "책",
        getFunc : function(){}
    }
}
```

- 렉시컬 환경 컴포넌트의 생성은, 엔진이 `function`, `with`문, `try-catch`문을 만났을 때 이뤄진다.
- 렉시컬 환경 컴포넌트는 **환경 레코드**(ER:Environment Record)와 **외부 렉시컬 참조**(OLER: Outer Lexical Environment Reference)로 구성된다.
  - 환경 레코드와 외부 렉시컬 참조에 name : value로 저장된다.
  - 환경 레코드에는 아래에 하나의 계층이 더 있다. 환경 레코드에는 함수 내부의 변수와 함수가 저장된다.
  - 외부 렉시컬 참조에는 함수가 속한 오브젝트에 있는 변수와 함수가 저장된다.

<br>
<br>

### 렉시컬 환경 컴포넌트 설정

1. 환경 레코드에 함수 안의 변수와 함수를 기록한다.
2. 외부 렉시컬 환경 참조에는 function Object의 `[[Scope]]`에 있는 것을 넣는다.
   - function Object를 만들 때, 내부 프로퍼티 `[[Scope]]`가 설정된다.
     - `[[Scope]]`에는 함수가 속한 오브젝트에 존재하는(함수가 가지고 있는 범위가 아니라) 변수와 함수를 `{name : value}`로 저장되어 있다.
   - 이제 이 함수가 호출되면 내부 프로퍼티에 담긴 내용을 외부 렉시컬 환경 참조에 설정하는 것이다.
     - 이렇게 실행 컨텍스트의 렉시컬 환경 참조 안에, 외부와 내부의 변수와 함수가 저장되게 된다. 즉, 함수 안과 밖의 함수와 변수를 모두 사용할 수 있게 된 것, 실행 콘텍스트 바깥으로 나갈 이유가 없게 되었다.(우리가 그렇게 코딩만 한다면, 엔진 처리가 빨라질 수 있다는 것이다)

<br>
<br>
<br>

# 변수 환경 컴포넌트

- 실행 컨텍스트 초기화 단계에서, 렉시컬 환경 컴포넌트와 같게 설정한다.
- 변수 환경 컴포넌트는 초기값을 복원할 때 사용하기 위함이다.
  - 함수가 실행되면, 실행 결과를 렉시컬 환경 컴포넌트에 설정하게 된다. 변수에 할당한 값이나 함수 자체가 변할 수 있게 된다.
  - 다음에 실행했을 때 똑같은 결과를 내기 위해선 초기값이 같아야된다. 따라서 엔진은 실행이 끝나면?? 언젠가 렉시컬 환경 컴포넌트를 초기화 해주는데, 이때 변수 환경 컴포넌트에 담긴 값으로 초기화를 한다.
- 변수 환경 컴포넌트는 with문에서 사용한다.(??? 다시 정리)
