# Closure

- function Object를 생성할 때, 함수가 속한 스코프를 function Object의 내부 프로퍼티 `[[Scope]]`에 설정하고,
- 함수가 호출되었을 때, `[[Scope]]`의 프로퍼티를 사용하는 매커니즘을 클로저라 한다.

#### 클로저는 지금까지 Scope를 사용한 것의 논리적인 설명에 불과하다.

<br>

## 클로저 논리

```javascript
실행컨텍스트 : {
    렉시컬환경컴포넌트 : {
        환경레코드 : {
            선언적환경레코드 : {},
            오브젝트환경레코드 : {}
        }
        외부렉시컬환경참조: {},
    },
    변수환경컴포넌트 : {},
    this바인딩컴포넌트 : {}
}
```

- 엔진은 function Object가 호출되면 실행 컨텍스트를 만들게 되는데, 함수 내부에 위치한 변수와 함수를 **선언적 환경 레코드**에 설정하게 된다.
- 또한 엔진은 function Object의 `[[Scope]]`에 저장된 변수와 함수를 **외부 렉시컬 환경 참조**에 바인딩 한다.
  - 그래서 우리는, 함수가 속한 Scope에 있는 변수와 함수를 참조해서 사용할 수 있게 된다. 참조이기 때문에, 내부에서 변경한 것이 외부에서도 적용된다.

#### 외부 렉시컬 환경 참조에 있는 것을, 함수 내부에 있는 것처럼 사용하는 것이 클로저의 논리다.

#### 구조에 대해 이해하고 있으면, 클로저라는 로직은 이해가 쉽다.

<br>

## 클로저 논리를 사용하여 설명

```javascript
function book() {
  var point = 100;

  var getPoint = function (param) {
    point = point + param;
    return point;
  };
  return getPoint; //함수를 반환
}

var obj = book();
console.log(obj(200));
```

- 외부 렉시컬 환경 참조 덕분에, 함수 안에 함수가 바깥의 함수에 선언된 변수를 사용할 수 있게 된다.

  - 이와 비슷한 것으로 객체 안의 함수를 호출할 때, 함수가 객체에 존재하는 변수를 참조하기 위해 this를 사용하는 것과 비슷하다.
  - 그러나 이렇게 외부 렉시컬 환경 참조 덕분에 this와 같은 키워드를 사용하지 않고도 접근이 가능하다.

- **getPoint** 반환해주고 다른 곳에서 쓰더라도, 엔진이 getPoint function Object를 생성해줄 때, `[[Scope]]`가 결정되기 때문에(즉, **Closure가 생성된다.**), 함수를 호출하는 시점이 언제든 간에, book 내부의 변수에 접근할 수 있다.\
  - 실행 컨텍스트가 만들어지면서 외부 렉시컬 환경 참조에 `[[Scope]]`가 들어가기 때문이다.

<br>

#### 이렇게 외부 렉시컬 환경 참조에, function Object의 [[Scope]]가 바인딩된 환경을 클로저라고 한다.

- **선언적 환경 레코드에 변수가 없으면, 외부 렉시컬 환경 참조에서 식별자 해결을 할 수 있다.** 여기까지가 클로저라고 보면 된다.

<br>
<hr>
<br>

# 클로저와 무명함수
