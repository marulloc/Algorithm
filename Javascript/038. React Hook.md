# React Hook

- 컴포넌트에 기능을 추가할 때 사용하는 함수다.
  - 컴포넌트에 상태 값을 추가하거나 자식 요소에 접근하는 등의 기능을 추가하고 싶을 때 훅을 사용하면 된다.
  - 리액트 훅이 나오기 전에는, **클래스형 컴포넌트**를 사용했다. 리액트 훅이 클래스형 컴포넌트를 대체할 수 있으며 장점이 많다.

<hr>
<br>
<br>

## hook `useState()`

- 상태값을 추가하기 위해 사용하는 훅

```jsx
const App = () => {
  const [count, setCount] = useState(0);

  const onClick = () => {
    setCount(count + 1);
    setCount(count + 1);
    console.log(count); //변경되지 않은 이전의 값을 출력함
  };

  console.log("re-render");

  return (
    <div onClick={onClick}>
      <h1>{count}</h1>
    </div>
  );
};
```

- `useState`는 배열을 반환한다. 첫 번째 아이템은 **상태값**, 두 번째 아이템은 **상태값 변경 함수**가 반환된다.
- `onClick()` 에서 상태 값 변경 함수를 두 번 호출했지만, 클릭을 하면 **2씩 증가하지 않고 1씩 증가한다.**
  - 상태값 변경 함수는 **비동기이면서 batch로 처리되기 때문에** 의도한대로 동작하지 않는다. **리액트는 효율적인 렌더링을 위해 여러 개의 상태값 변경 요청을 배치batch로 처리한다.**
  - 따라서 onClick 함수가 호출되어도 `console.log(re-render)`는 한 번만 출력될 것이다.

<br>

### React State 비동기성

> `console.log(count)`
> //=> 변경되지 않은 이전의 값을 출력함
> 이것은 **State가 비동기적으로 처리됨**을 의미한다.

- **만약 동기 처리를 하게되면, 하나의 상태값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능 이슈가 생길 수 있다.**
- React는 batch update를 16ms 단위로 진행한다. 16ms 동안 변경된 상태 값들을 모아서 단 **한 번** 리렌더링을 진행한다.
- setState 이후 바로 상태값을 참조하여 다른 작업을 하려면 **동기화**가 필요한데, 이때 사용하는 것이 **react-thunk**, **react-saga**이다.

<br>

### React State 일괄 처리

> `console.log(re-render)`
> //=>setCount가 두 번 호출되었는데 한 번만 리렌더링 됨
> 이것은 **React의 상태 변경이 batch 일괄 처리 됨**을 의미한다.

- React는 batch update를 16ms 단위로 진행한다. 16ms 동안 변경된 상태 값들을 모아서 단 **한 번** 리렌더링을 진행한다.
  - setCount가 처음 호출되더라도, 일괄처리가 일어나기 때문에, **두 번째 setCount에서 상태 값은 여전히 증가되지 않은 상태다.** 따라서, 일괄 처리에 의해, 비동기에 의해 두 번 상태변경 함수를 처리해도 의미가 없다.
- 만약 두 번 호출하는 것을 원한다면 **상태값 변경 함수에 인자로 "함수"를 넣으면 된다.**
  ```jsx
  const onClick = () => {
    setCount((v) => v + 1);
    setCount((v) => v + 1);
    console.log(count);
  };
  console.log("re-render");
  ```
  - 상태변경 함수의 함수는 **인자로 처리되기 "직전"의 상태 값을 받게 되기 때문에 두 번 호출이 정상적으로 동작한다.**

<br>

> **`onClick` 함수가 리액트 요소에 의해 호출될 때만 batch 처리가 된다.**
> 만약 onClick 함수를 외부에서 호출하면, 일괄처리가 되지 않고 클릭이 발생할 때 마다 리-렌더링이 발생하게 된다. 외부 호출 또한 일괄처리를 하고 싶다면 `ReactDOM.unstable_batchedUpdate()`라는 메소드를 사용하면 된다.

<br>

### 객체 State

```jsx
const App = () => {
  const [state, setState] = useState({ name: "조병건", age: 28 });

  const onClick = () => {
    //setState(state.age + 1)
    setState({ ...state, age: state.age + 1 });
  };
};
```

- 클릭을 할 때, state의 프로퍼티 age의 값은 바뀐다.
- 그러나 상태가 객체일 경우에는 State는 참조값을 갖게된다.
- 따라서 내부 값이 변하더라도, State의 참조값은 변경되지 않으므로 **상태 변화를 리액트가 감지할 수 없고 리렌더링 되지 않는다.**
- **객체를 새로 만들어 할당해야 이 문제를 해결할 수 있다.**
  > 그러나, 이렇게 여러 상태를 객체로 묶어 관리할 때는 useState보다, **useReducer**라는 훅이 더 적합하다.

<hr>
<br>
<br>
<br>

## hook `useEffect()`

- 부수효과를 처리하기 위한 훅
- 부수효과란 외부의 상태를 변경하는 것을 의미한다. 서버 API를 호출하거나, 이벤트 핸들러를 등록하는 것이 부수효과다.
- 부수효과가 많은 프로젝트는, **순수 함수가 가지는 여러 장점을 포기하게 되는 등, 유닛테스트가 힘들어진다.**

```jsx
useEffect(() => {
  console.log("side effect");
}, [variable]);
```

- 첫 번째 매개변수로 함수를 입력한다. **이 함수는 컴포넌트가 렌더링 된 "후"에 호출된다.** 더 정확하게 하면, 렌더링 결과가 실제 돔에 반영되고 **비동기로 호출**된다. 이 함수를 **부수 효과 함수**라고 한다.
- 두 번째 매개변수로 배열을 입력한다. **이 배열은 의존성 배열이라고 부른다.** 리-렌더가 발생할 때 마다 부수효과 함수가 실행되는 것은 매우 비효율적이다.(부수효과함수가 하는 일은 API 호출과 같은 일이므로)
  - 이 배열의 요소가 변화될 때마다, 부수효과함수가 실행되도록 하는 것이다.
  - 만약 배열이 비어있으면, 컴포넌트가 생성될 때만 부수효과 함수가 호출된다.

<br>

### 부수효과함수의 반환

```jsx
useEffect(() => {
  console.log("side effect");
  return () => {
    console.log("called");
  };
}, [variable]);
```

- 부수효과가 반환하는 함수 `return () => {console.log("called") }`은 **다음 부수효과함수가 호출되기 "직전"에 호출되거나** 또는, 컴포넌트가 사라지기 직전, 즉, **컴포넌트가 unmount되기 직전에 마지막으로 호출된다.**

  - 따라서 **이벤트 핸들러 등록과 제거에 유용하다.**

  ```jsx
  useEffect(() => {
    const handler = () => {
      console.log("클릭 핸들러");
    };
    window.addEventListener("click", handler);

    return () => {
      window.removeEventListener("click", handler);
    };
  }, []);
  ```

  - 컴포넌트가 생성될 때, 이벤트 핸들러를 등록한다.
  - 컴포넌트가 사라질 때, 이벤트 핸들러를 제거한다
