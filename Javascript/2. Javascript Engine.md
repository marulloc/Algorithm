# Javascript는 인터프리터 언어가 확실한가?

- javascript는 dynamically-typed, interpreted language라고 여겨지지만 javascirpt는 compiled language다.
- JS는 전통적인 컴파일러 언어와 달리 컴파일만을 하는 시간을 따로 가지진 않지만, 매 코드 실행 **직전**에 전통적인 컴파일러 언어가 가지는 **Compilation**과정을 거친다. 즉 JS는 전통적인 컴파일 언어는 아니지만, 결국 **컴파일러 언어**다.

<br>

#### 전통적인 컴파일러 언어는 Compilation 작업을 한다. Compilation 작업은 아래의 세가지 단계로 구성된다.

1. Tokenizing/Lexing
   컴파일러에 들어오는 것은 **"문자열"**로 작성된 코드다. 문자열을 **token**으로 분리하는데, 각 언어의 문법에 맞춰 의미 있는 단위로 분리한다. 마찬가지로 JS또한 토크나이징 과정을 거친다.
   `var a = 5`라는 문자열 코드가 들어오면, 토크나이징 과정에서 `var`,`a`,`=`,`5`의 토큰이 발생한다.

2. Parsing
   토크나이징 과정이 끝나면, 토큰을 가지고 **AST(추상구문트리)**를 만드는 Parsing 단계를 진행한다.

3. Code Generation
   AST를 기반으로 실행 코드를 만드는 작업이다.

자바스크립트 엔진은 이 세 가지 단계뿐 아니라, 전통적인 컴파일러 언어의 컴파일러의 기능보다 많은 것을 제공한다. 위에서 말했듯이 JS는 C처럼 코드 전체를 실행가능한 파일로 만드는 "전통적인 컴파일 타임"이 없기 때문에, 코드 최적화 시간이 부족하다. 이런 시간적 부족함 때문에, JS 엔진은 최적화를 위한 복잡한 기능을 가지고 있다. 그것에 대해서 자세히 알아볼 필요는 아직 없는 것 같다.

<br>

#### JS Compilation의 주체

1. **_Engine_**
   Compilation 작업을 총괄하고, 생성된 코드를 실행까지 시키는 주체다.

2. **_Compiler_**
   Compilation의 Parsing과 Code Generation을 담당한다.

3. **_Scope_**
   **스코프는 식별자 이름(변수명)으로 변수를 찾기 위한 규칙의 집합이다.**
   식별자(변수)의 목록**스코프 컬렉션**과 또 엔진이 실행해야 할 코드에 변수등이 있을 때, 현재 위치에서 해당 변수에 접근 가능한지 여부를 기록해둔 공간이다.

<br>

#### Compilation 순서

Code : `var a = 2;`

1. Engine에 위 코드가 문자열로 들어오면, 문자열을 2개로 나눈다.

   - 컴파일러가 컴파일레이션 과정에서 처리할 구문 `var a`
   - 엔진이 코드 실행때 처리할 구문 `a = 2;`
     구문을 나눴으면, 컴파일러에게 두 구문을 모두 넘겨준다.

2. Compiler의 lexing/tokenizing 단계로 진입하여, 구문을 token으로 나눈다.
3. Compiler의 Parsing 단계로 진입하여, token을 가지고 AST추상구문트리를 만든다.
4. Compiler의 Code Generation 단계로 진입, Scope를 뒤져보면서 코드를 생성한다.

   1. `var a`구문의 코드생성 단계

      - Scope에서 변수 a가 **특정 스코프 컬렉션 안에 위치해있는지** 찾는다.
      - 변수 a가 이미 존재한다면, Compiler는 선언 과정을 스킵한다.
      - 아직 존재하지 않는다면, Compiler는 변수 a를 스코프 컬렉션 내에 선언한다.

   2. `a = 2`구문의 코드 생성단계
      Compiler는 할당문을 Engine이 실행할 수 있도록 기계어로 변환하는 과정을 진행한다.

5. Engine이 할당문을 실행한다.
   코드를 실행하기 전에 먼저 Engine은 Scope를 살핀다.
   - Engine은 Scope에서, a라는 변수가 현재 스코프 컬렉션 내에서 접근가능한지 확인한다.
   - 접근이 가능하다면, 변수 a를 그대로 사용하고 할당을 진행한다.
   - 접근이 불가능하다면, Engine은 다른 스코프(**중첩 스코프**)에서 변수 a를 찾아본다.
   - 변수 a가 전혀 찾아지지 않는다면 에러를 뱉어내겠지

<br>

#### Engine과 Scope의 대화

Engine은 코드를 실행하기 전에 Scope를 뒤져보는데, 변수 a를 스코프 컬렉션 내에서 찾기위해 LHS, RHS와 검색방식을 쓴다. 어느 검색방식을 쓰냐에 따라서 검색 결과가 달라진다. **LHS(Left Hand Side)**와 **RHS(Right Hand Side)**의 left, right 방향은 **대입 연산의 방향**을 의미한다.

- LHS는 변수가 대입 연산자의 왼쪽에 있을 때 수행하는데, **변수의 값을 알 필요가 없을 때** 수행한다.
  `a = 2`에서 a에 대한 참조는 LHS 참조다. `= 2` 를 수행하기 위해서 a의 값을 알 필요가 없으므로 LHS를 수행한다.
- RHS는 변수가 대입 연산자의 오른쪽에 있을 때 수행한다. 솔직히 말하면, 왼쪽이 아닌 모든경우에 수행한다. **변수 값을 알아오는 검색방식**이라고 보면 된다.
  `console.log( a )`에서 a에 대한 참조는 RHS 참조다. .log()에 a의 값을 넘겨줘야 하므로 RHS 방식을 쓴다.

<br>

예시를 보자
`
function foo( a ){
console.log( a )
}

foo( 2 )
`

1. `foo( )`는 RHS다. foo를 들고 스코프 컬렉션에 가서 foo의 값을 찾아온다.
2. `foo( 2 )`에서는 매개변수`a = 2`에 값을 대입하기 위해 LHS 참조를 사용한다.
3. `console.log( )`이 실행되려면 참조가 필요하므로, console 객체를 RHS 검색해서 log 메서드가 있는 지확인한다.
4. `.log( a )` a의 값을 알아오기 위해 RHS 참조가 필요하고, .log 메소드의 매개변수에 값을 할당하기 위해 LHS 참조가 필요하다.
