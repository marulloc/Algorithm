자바스크립트는 문장 하나하나가 들어올 때마다
컴파일->실행 단계를 거친다.

컴파일 단계에서 메모리를 확보한다.

원래 c 언어라면, 전역변수와 static변수는 data area에
malloc을 통해 할당된 동적변수라면 heap area에
지역변수와 매개변수는 stack area에 저장된다.

그러나 자바스크립트는 문장 하나 하나를 컴파일한다. 어떻게보면 계속 동적할당을 하는 것인데
자바스크립트의 변수는 모두 heap area에 저장된다는 것일까??

여기서 자바스크립트 엔진의 동작을 봐야된다.
자바스크립트는 JVM과 같은 가상머신이다. 에뮬레이터라고 보면 될 듯
자바스크립트 엔진은 하나의 프로그램으로, 메모리 공간 확보와 사용, 가비지 컬렉션을 통한 메모리 해제의 기능과
실제 코드를 실행시켜주는 역할을 한다.

자바스크립트 엔진은 memory heap과 call stack으로 구성된다.
함수 내에 위치한 지역변수나 매개변수는 함수와 함께 **실행컨텍스트**로 묶여 call stack에 stack frame이란 이름으로 들어간다. 또한 js의 원시 데이터는 call stack에 저장된다....
근데 global context도 있어서 전역변수도 실행컨텍스트에 위치한다. 따라서 모든 변수는 실행컨텍스트에 위치한다고 볼 수 있다.

# 실행컨텍스트와 변수

전역 컨텍스트도 있고, 함수 컨텍스트도 있으니까,
결국 모든 변수는 실행 컨텍스트에 속한다.
ㄹㅇ 실행 컨텍스트는, 실행하기 위한 정보를 담고 있는 블록이다.
실행 컨텍스트는 CALL STACK에 담김
CALL STACK을 하나하나 처리하면서 엔진이 동작하는 것이다.

실행 컨텍스트를 만들때 호이스팅을 해서 만든다.

따라서 CALL STACK에서 하나씩 컨텍스트를 뽑아서 실행할 때,
변수 선언이 가장 최상단에 위치하게 된다.

변수 선언이 진행되면 Engine은 메모리를 확보하는데,

참조타입은 callstack -> heap 메모리 형식으로 저장된다.

- 참조타입의 식별자(변수명)은 call stack에 저장되고, 데이터 { }, [](참조 타입 데이터)는 heap 에 저장되는 것임 (결국 얘 변수명(식별자)도 실행 컨텍스트 안에 위치했을테니까 call stack에 위치하게 됨)
- 참조타입은 속성들의 집합이다. 따라서 참조타입은 원시타입보다 추가적인 메모리 공간을 할당받는데, 거기서 속성들의 식별자 주소를 담고있게 된다. (만약참조타입이면 위처럼 또 가리키게되겠지)

- 원시타입은 실행컨텍스트에 속한다. 따라서 결국 call stack에 위치하게 되는 것??

- 즉 모든 변수는 실행컨텍스트에 속해있다. 참조타입은 특성상 추가적으로 heap을 바라보고 있는 거고.. 맞냐?

### 참조타입

참조타입 속성이 25를 가리키고 다른 객체가 25를 가리킨다고 했을 때,
25라는 값이 메모리에 2개 할당되어 있진 않음 , 메모리 효율적으로 활용하기 위해
25라는 것이 하나에 저장되어있고, 얘를 여러곳에서 가리키는 것임
그것을 해주는 것이 engine의 스코프임, engine의 컴파일러는 a = 5라는 문장에서, a라는 것을 미리 확보해두고, 스코프의 리스트를 갱신해둔다.
그리고 engine이 =5를 실행하려고 할 때, 5가 있는지 스코프에게 물어보고, 있으면 스코프 리스트에 있는 걸 가져다가 쓰는것??? 맞냐??
