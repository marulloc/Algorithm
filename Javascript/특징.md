#### 프로그램이 로드되면 아래 4개의 메모리 공간을 할당 받게 된다.

1. Code area
2. data area
   - 전역변수나 static 변수들이 위치한다.
3. heap area
   - 동적할당 된 변수들이 저장된다.
   - 따라서 **런타임**에 크기가 결정된다.
4. stack area
   - 지역변수와 매개변수가 저장된다.
   - 따라서 **컴파일 타임**에 크기가 결정된다.
   - 함수 호출시, 하나의 stack frame이 생성되고 stack에 push된다.
   - 함수 실행이 완료되면, stack에서 pop 된다.

### Javascript는 ??

Javascript는 인터프리터 언어로 여겨진다.
인터프리터 언어의 특정상 컴파일 타임이 따로 없다. 그렇다면 Javascript는 stack area를 쓰지 않는 것인가?

Javascript는 인터프리터 언어지만, Javascript는 js code를 컴파일 하는 것처럼 행동한다.

javascript는 dynamically-typed, interpreted language라고 여겨지지만 javascirpt는 compiled language다. 전통적인 컴파일 언어는 아니지만, 결국 컴파일된 언어다.

dynamically - typed: 변수 선언시 타입이 결정되는 것이 아니라, 할당할 때 타입이 정해진다.
interpreted language: 컴파일 타임이 따로 없기 때문에

### 우선 인터프리터 언어를 생각해보자

인터프리터 언어를 구분짓는 것은 static typing 이냐 dynamic typing이다. 이 의미는 결국 static binding vs dynamic binding이냐 -> 더 나아가 compile time vs run time이다.

컴파일타임 vs 런타임
스태틱타이핑 vs 동적타이핑
스태틱바인딩 vs 동적바인딩

### javscript 컴파일레이션

자바 스크립트 컴파일은 다른 언어와 마찬가지로 빌드 단계에서 미리 발생하지 않기 때문에 자바 스크립트 엔진은 최적화 할 시간이 충분하지 않습니다 (다른 언어 컴파일러처럼).
따라서, Javascript는 코드 한줄을 실행하기 직전에 되어서야 컴파일을 한다. 자바스크립트 컴파일러는 let foo=5 라는 문자열을 받고 컴파일을 한 다음에 실행을 한다는 것이다.

##### 대부분 컴파일 언어는 다음과 같은 컴파일 과정을 거친다.

자바스크립트도 컴파일 언어로 볼 수 있으니까 이 3단계를 따르는 것

1. Tokenizing/Lexing: 코드를 의미있는 조각(token)으로 만드는 과정. (예) var a = 2; -> var, a, =, 2, ;
   렉서는 토크나이저의 한 종류지만, 차이점은 더 알아보자.

2. Parsing: 문법 구조를 반영하여 중첩 원소를 갖는 트리형태로 바꾸는 과정. 파싱의 결과로 만들어진 트리를 AST(추상 구문 트리)라 부름

3. Code-Generation: AST를 실행코드(기계어)로 바꾸는 과정

##### 코드의 해석(컴파일) 관점에서, 코드의 실행으로 관점을 옮겨 보면 엔진, 컴파일러, 스코프가 상호작용하게 됩니다.

- 엔진 : 컴파일레이션 시작부터 끝까지 모든 과정과 프로그램 실행을 책임짐 (런타임 환경을 실질적으로 엔진이 담당하고 있다고 볼 수 있겠습니다.)
- 컴파일러 : 엔진을 보조하는 역할로, 파싱, 코드 생성 등(컴파일레이션)을 한다.
- 스코프 : 엔진을 보조하는 역할로, 식별자(변수)들을 모으고 리스트를 작성해둔다. 또한 엔진이 실행해야 할 문장이 접근 가능한 문장인지 확인한다.

var foo=5;는 한 문장이지만, javascript engine은 이것을 2개로 나눈다. 하나는 컴파일러가 컴파일 시간에 사용하기 위한 것으로, 하나는 engine이 실행시간에 실행시킬 문장으로 나눈다.

1. lexing을 통해 token으로 문장을 나누고 parse한다.
2. 이제 code generation 단계로 넘어간다.
   1. 컴파일러는 `var foo`라는 문장을 만나면, 스코프에게 이 변수가 이미 존재하는지 물어본다.
   2. 스코프는 리스트를 확인하고 응답을 해준다.
   3. 만약 이미 존재한다면 컴파일러는 변수 선언(메모리 확보)단계를 건너 뛴다.
   4. 만약 없다면, foo라는 변수를 리스트에 넣어달라고 스코프에게 요청한다.
   5. 이제 컴파일러는 code를 만들어서 engine에게 넘긴다.
   6. 컴파일러는 `=5`라는 할당문을 실행하려고 한다. 이때 먼저 스코프에게 접근가능한지 여부를 물어본다.
   7. 만약 접근 가능하다면 변수에 할당문을 진행한다. 아니라면 에러를 뱉어내겠지.
