# 코딩테스트를 위한 파이썬

<br>
<br>

### 시간 복잡도

코딩테스트에서 차수가 작은 항이나, 상수항을 완전히 무시하면 안된다. 상수항이 큰 경우 코딩테스트의 채점시간을 넘길 수 있다.

- 보통 코딩테스트의 시간제한은 1~5초다.
- C언어 기준 연산횟수 10억번은 1초에 해당된다. 파이썬은 c보다 느리다.
- 시간 제한이 1초인 경우
  - (N = 최대 500) -> O(N^3)까지 가능하다.
  - (N = 최대 2000) -> O(N^2)까지 가능하다.
  - (N = 최대 100,000) - > O(NlogN)까지 가능하다.
  - (N = 최대 10,000,000) -> O(N)으로 해결해야 한다.

<br>
<br>

### 실수 사용

- 지수 표현 방식으로 INF를 사용하자.
  - `INF = 10e9`
- 실수를 이용할 때, 정확하게 계산되지 않는다는 점을 잊지 말자.
  - `round(실수, 반올림하고자하는 위치 - 1)`을 통해 반올림 해주자.

<br>
<br>

### 연산자

- `/`연산자는 실수형으로 처리한다.
  - 몫만 취하고 싶으면 `//`를 사용하자
- `**`거듭제곱 연산자 또한 존재한다.
- `+`, `*`로 문자열 연산 또한 가능하다.

<br>
<br>

### 리스트 자료형

- 비어있는 리스트 선언 `[]`이나, `list()`를 사용한다.
- 초기화
  - 0으로 초기화 하고 싶다면, 간단하게 `a = [0] * 개수`를 쓰면 된다.
  - 다른 값으로 초기화하려면 리스트 컴프리헨션 사용 `a = [10 for _ in range(10)]`
- **리스트 컴프리헨션**
  - `arr = [i for i in range(20) if i % 2 == 1]` 0부터 19까지의 홀수만 리스트에 넣는다.
  - 2차원 리스트를 초기화할 때는 반드시 리스트 컴프리헨션을 써야함 `arr = [[0]*열] * 행`은 동일한 배열 `[[0]*열]`을 행만큼 추가하는 것이다. 같은 참조값이라서 요소를 바꾸면 함께 변한다. 따라서 리스트 컴프리헨션을 사용하자.
  - 따라서 다음과 같이 초기화한다. `arr = [ [0] * 열 for _ in range(행)]`
- 메서드
  - `arr.append()` : 리스트에 원소 삽입 `O(1)`
  - `arr.reverse()` : 리스트의 순서 뒤집기
  - `arr.insert(인덱스)` : 특정 인덱스 위치에 원소를 삽입 `O(N)`으로 은근 느림
  - `arr.remove(값)` : 특정 값을 갖는 원소를 하나만 삭제
  - `arr.count(값)` : 특정 값을 갖는 원소의 개수를 센다.
  - `arr.sort(reverse=True/False)` : True인 경우 내림차순으로 정렬
  - 특정 값을 갖는 모든 원소를 삭제하려면? `not in`을 이용하자.
    - `result = [ i for i in arr if i not in remove_set ]`
- 인덱싱과 슬라이싱 가능하다.
- `+`연산으로 리스트를 합칠 수 있다.

<br>
<br>

### 튜플 자료형

`a = (1,2,3,4)`

- 튜플은 한 번 선언된 값을 변경할 수 없다. 즉 대입연산자를 사용할 수 없다.
- `t2 = (1,)` : 단지 1개의 요소만을 가질 때는 요소 뒤에 콤마(,)를 반드시 붙여야 한다.
- 위의 조건 빼고는 리스트와 똑같다.
  - 인덱싱과 슬라이싱 가능
- 튜플은 그래프 알고리즘을 구현할 때 자주 사용된다. 그래프 알고리즘에서 큐를 사용하는 경우 큐에 넣어주는 데이터를 튜플형으로 해준다. (변경을 막기 위해)

<br>
<br>

### 사전 자료형

`data = dict()`

- k/v 형태로 저장되어 O(1)시간에 검색과 수정이 가능하다.
- 튜플이나 리스트에서 처럼 `in` 연산자로 키값이 존재하는지 판단 가능하다.
  - `if '사과' in data`
- key값만 뽑아서 리스트로 만들고 싶다면 `key_list = data.keys()`
- value값만 뽑아서 리스트로 만들고 싶으면 `value_list = data.values()`
- `data[key이름]`으로 원소에 접근 가능하다.

<br>
<br>

### 집합 자료형

`data = set([1,2,3,3,3])`

- 리스트나 문자열을 이용해서 만들곤한다.
- 중복을 허용하지 않으며 순서가 없기 때문에 인덱싱과 슬라이싱이 안된다.
- 키값이 없고 값으로만 데이터를 담는다. 그러나 특정 원소가 존재하는지를 검사하는 연산의 시간복잡도는 O(1)로 짧다
- 보통 데이터가 이전에 등장한 적이 있는지 여부를 체크할 때 사용한다.
- 집합 연산
  - `&` 교집합 연산
  - `|` 합집합 연산
  - `-` 차집합 연산
- 메소드
  - `data.add(값)` 집합에 원소 추가
  - `data.update([값,값])` 집합에 원소 여러개 추가
  - `data.remove(3)` 특정한 값 제거
