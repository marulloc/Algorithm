# 리액트 최적화

리액트가 실행될 때 가장 많은 CPU 자원을 사용하는 것은 **렌더링**이다. 리액트는 실행 중에 쉬지않고 렌더링을 진행한다. (_16ms 마다 렌더링 이벤트가 발생하여 렌더링을 진행한다_) 리액트는 UI 데이터와 컴포넌트 함수를 호출하면서 화면을 그린다.(_리액트는 UI 데이터(속성값, 상태값)가 변경되면, 컴포넌트 함수를 호출하여 렌더링을 진행한다._) **그 과정에서 대부분의 연산은 컴포넌트 함수 실행 그리고 가상돔에서 발생한다.**

> 따라서 우리는 **컴포넌트 함수 실행 과정에서의 최적화**와 **가상돔 최적화**를 통해 리액트 APP을 최적화 할 수 있다.

<br>
<br>

## 리액트의 렌더링 과정

1. 이전 렌더링 결과를 재사용할지 판단한다.
   - 여기서는 속성값이나 상태값이 이전과 달라졌는지 판단하는 단계다.
   - 만약 재사용할 것이라면 리액트는 아래 단계를 수행하지 않는다. **우리는 React.memo를 통해 아래 단계가 실행되지 않게 만들 수 있다.**
2. 컴포넌트 함수를 호출한다.
3. 방금 생성된 가상돔과 이전의 가상돔을 비교해서, 변경된 부분만 실제돔에 적용한다.

<br>
<hr>
<br>
<br>

## 리액트 최적화 방법

### `React.memo`로 렌더링 결과 재사용하기

일반적으로 memo함수로 감싸지 않으면, 부모컴포넌트가 렌더링이 될 때마다 속성값이 변하지 않아도 자식 컴포넌트는 리-렌더 된다.

```jsx
function SomeComponent({value}{...})
export default React.memo(SomeComponent, 속성값비교함수)
```

- 컴포넌트의 속성값이나 상태값이 변경되면 리액트는 컴포넌트를 다시 그리게 된다.
- 그런데 React.memo로 컴포넌트를 감싸게 되면 리액트는 **속성값 비교함수**를 호출하게 된다.
  - **사실 React.memo 함수는 두 번째 인자로 함수를 받는다.** 이 함수가 속성값 비교 함수다.
  - 속성값 비교함수는 이전/이후 속성값을 매개변수로 받아서 true/false를 반환한다.
  - `true`를 반환하면 이전 속성값을 재사용하고
  - `false`를 반환하면 새로운 속성값으로 컴포넌트 함수를 호출하고 가상돔을 업데이트하고, 실제 돔에 반영하는 과정을 거치게 된다.

> 1. 속성값 비교함수를 입력하지 않으면, 리액트 내부의 비교함수가 자동으로 호출된다. 디폴트로 깔린 속성값비교함수는 **얕은비교**를 수행하게 된다.

- 따라서, 속성값이 객체로 넘어오는 경우 **깊은비교**를 해야하는데 이때, 우리가 작성한 함수를 넣어주면 된다.(_당연히 이때의 속성값 비교함수는 브루트포스로 객체의 모든 프로퍼티의 일치 여부를 판단해야 된다._)

> 2. memo함수로 감싸지 않으면, 부모컴포넌트가 렌더링이 될 때마다 속성값이 변하지 않아도 자식 컴포넌트는 리-렌더 된다. 사실 항상 속성값 비교함수를 호출하는데, memo를 감싸지 않은경우 항상 false를 반환하는 속성값 비교함수가 호출되는 것이다.

- 속성값이 변경되지 않는다면 결국 실제 돔으로 보이는 화면에 문제는 없을 것이다. 그러나 렌더링 성능이 중요한 상황에서는 memo함수를 사용하여, **컴포넌트 함수 실행과 가상돔 비교계산을 생략하여 성능 최적화를 하자.**

<br>
<br>
<br>

### `불변변수`로 속성값과 상태값의 얕은비교만 수행하도록 만들기
