# **_React_**

> #### 목차
>
> 1. _About React_
> 2. _Virtual DOM_
> 3. _Hooks_
> 4. _React optimization_

<br>

## **_1. About React_**

### [***About React***] UI 라이브러리 리액트

리액트는 UI "라이브러리"다.
따라서 하나의 Web APP을 완성하려면 다른 라이브러리들을 필요로 한다.

<br>

### [***About React***] SPA

<br>

### [***About React***] UI 데이터 관리

- 리액트는 **UI 데이터가 변경되면 화면을 리-렌더 한다.**<br>
  리액트에서 UI 데이터는 "속성값"과 "상태값"이다. 따라서, 속성값과 상태값이 아닌 일반 변수가 변경되면 리액트는 변경을 인지하지 못하고 화면을 리-렌더하지 않는다.

- 부모가 리-렌더 되면 자식 또한 리-렌더 된다.<br>
  부모가 리-렌더 되면 자식 컴포넌트의 속성값과 상태값이 바뀌지 않아도 자동으로 리-렌더 되는데, 이때 **React.memo**로 리-렌더를 방지하여 최적화 할 수 있다.

- 상태값이 **객체**인 경우<br>
  리액트는 **얕은 비교**를 통해 상태 변경 여부를 판단한다.
  따라서 상태가 **객체인 경우 참조값을 비교**하기 때문에, 객체(상태의 집합)의 속성(하나의 상태)이 변경되어도 똑같다고 판단하여 리-렌더를 진행하지 않는다.
  따라서, 우리는 항상 상태를 **불변 객체**로 다뤄야 한다. 불변객체로 다루면 리액트의 **얕은 비교로도 객체, 일반 변수의 상태 변경을 파악할 수 있다.**

- 속성값을 **객체 리터럴, 함수 리터럴**로 넘겨주는 경우<br>
  자식 컴포넌트의 속성값에 객체나 함수를 리터럴 형태로 넘겨주는 경우, 부모가 리-렌더 될 때, 객체나 함수가 재생성 되면서 자식들이 리-렌더 된다.
  이때 메모이제이션을 해주는 훅(**useCallback**, **useMemo**)을 사용하거나 상수로 쓰이는 객체는 컴포넌트 외부로 빼놓아 렌더링 최적화를 해야한다.

<br>

### [***About React***] 상태 변경은 "비동기 + 일괄" 처리

```jsx
const [count, setCount] = useState(0);
const onClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  console.log(count); //변경되지 않은 이전의 값을 출력함
};
```

- **비동기 처리**<br>
  만약 상태 변경에 대해 "동기 처리"를 하게 되면, 상태 변경 함수가 호출될 때마다 화면을 다시 그리는 동안 브라우저가 멈추므로 성능 이슈가 발생한다.
- **일괄 처리**<br>
  리액트는 상태 업데이트를 16ms마다 일괄로 처리하여 리-렌더를 진행한다. `setCount`를 두 번 해도, 두 번째 `setCount`는 아직 증가되지 않은 count 값을 들고 대기 queue에 들어가기 때문에 `+1`은 단 한번만 이뤄진다. queue가 존재하여 비동기와 일괄처리 되더라도 "**호출순서 === 처리순서**"가 보장된다. 만약, 상태 변경을 바로바로 한다면 상태 변경 함수가 호출될 때 마다 화면을 다시 그리므로 성능 이슈가 발생한다.

<br>

### [***About React***] 리액트의 렌더링 과정

리액트의 렌더링 단계는 다음과 같다.

1. 최초의 가상돔이 만들어진다.
2. 최초의 가상돔을 실제돔에 적용한다.
3. 상태가 변경되면, 상태가 변경된 컴포넌트의 컴포넌트 함수를 호출하여 새로운 가상돔을 생성한다.
4. 이전에 존재하던 가상돔과 새롭게 생성된 가상돔을 비교하여 변경점을 찾는다.(가상돔은 메모리에 적재되어 있다. 가상돔은 JS객체라서 가능하다.)
5. 변경점을 실제돔에 적용한다.

<br>
<br>

## **_2. Virtual DOM_**

### [***Virtual DOM***] Why?

브라우저의 엔진은 그렇게 좋은 엔진이 아니다. 화면을 갱신하는데 굉장히 오랜 시간을 소모하게 되기 때문에, 화면 갱신(실제 돔 조작)을 최소화해야 한다. 또한 실제돔을 조작하기 위해 DOM Tree를 순회해야 하는데, SPA가 만연한 세상에서 DOM Tree의 depth는 `querySelector`와 같은 함수로 매번 순회하기에 너무 깊다.

<br>

- 리액트는 가상돔을 메모리에 두고, 새로운 가상돔을 만들어 이전의 가상돔과 비교를 통해 변경된 부분만을 실제돔에 적용한다. 즉, 화면 렌더링에 있어 나름의 최적화가 되어 있다.
  > 이 가상돔의 존재가 리액트 최적화의 전부는 아니다.
  > 가상돔은 리액트가 사용하기 위한 정보가 담겨있는 **단순한 JS 객체다.** 따라서 메모리에 로드되어 있다.

<br>

- 리액트는 컴포넌트 함수 내부에서 바로 DOM을 조작할 수 있다.
  > 실제 DOM을 조작하는 것은 아니다. 가상돔을 조작하는 것이다. 그러나 결국 실제돔에 적용된다.

### [***Virtual DOM***] _Babel_ 없는 _React_

### [***Virtual DOM***] _createElement_ 와 _React Element_

### [***Virtual DOM***] _ReactDOM.render()_

### [***Virtual DOM***] _Virtual DOM_

### [***Virtual DOM***] _렌더 단계_

### [***Virtual DOM***] _커밋 단계_ (more)

### [***Virtual DOM***] _fiber_ (more)

<br>
<br>

## **_3. Hooks_**

### [***Hooks***] Hook 사용 규칙

1. 컴포넌트 내에서 hook 호출 순서는 항상 같아야 한다.
   - React가 useState 와 useEffect 가 여러 번 호출되는 중에도 Hook의 상태를 올바르게 유지할 수 있다 → React가 Hook이 호출되는 순서에 의존하여 각 useState와 useEffect를 구분하기 때문!
   - 참고: [https://ko.reactjs.org/docs/hooks-rules.html#explanation](https://ko.reactjs.org/docs/hooks-rules.html#explanation)
2. 함수형 컴포넌트나 커스텀 훅 내에서만 호출되어야 한다.

<br>
<br>

### [***Hooks***] useState

- 함수형 컴포넌트에 상태를 추가하기 위해 사용하는 Hook.
- 반환값은 [상태, 상태변경함수]
- 상태 변경은 비동기이며 일괄로 처리된다. 일괄처리 될 때, 호출 순서 === 처리 순서는 보장된다.
  - 만약 상태 변경에 대해 "동기 처리"를 하게 되면, 상태 변경 함수가 호출될 때마다 화면을 다시 그리는 동안 브라우저가 멈추므로 성능 이슈가 발생한다.
  - 일괄 처리: 리액트는 상태 업데이트를 16ms마다 일괄로 처리하여 리-렌더를 진행한다. 만약, 상태 변경을 바로바로 한다면 상태 변경 함수가 호출될 때 마다 화면을 다시 그리므로 성능 이슈가 발생한다.
- 상태 변경 코드를 동기적으로 실행하기 위해 함수형 업데이트를 사용하기도 한다.
  - // 최적화 & 테스트 효율성 & 동기적인 실행
- 상태값은 불변변수로 다뤄야한다.
  - 리액트는 단순비교로 상태 변경을 판단한다.
  - 만약 상태가 객체인 경우엔, 참조값을 들고있기 때문에, 상태 객체의 프로퍼티(하나의 상태)가 변경되어도 리액트는 알 수 없다.
  - 불변객체로 다루면, 참조값이 변경되기 때문에 상태값 변경을 단순비교로도 알 수 있다.
    [사이드이펙트 쪽으로도 알아봐야할 듯]
- 상탯값 변경함수와 클래스형 컴포넌트에서의 setState와의 차이점
  - setState메서드는 기존 상탯값과 새로 입력된 값을 병합한다
  - useState 훅의 상탯값 변경함수는 이전 상탯값을 덮어쓴다.
  - useState 훅은 이전 상탯값을 덮어쓰기 때문에 ...state와 같은 코드가 필요하다. 이렇게 상탯값을 하나의 객체로 관리할 때는 useReducer 훅을 사용하는 것이 좋다.

<br>

**🤔 좀더 검증이 필요한 뽀인트들**

- setState 함수는 비동기로 처리되는데 메인 프로세스 중에 호출된 모든 setState가 모두 처리되기 전에 컴포넌트가 렌더링되지는 않는다.
- 상태에 대한 동일한 key에 접근하여 값을 변경하는 setState에 대해서는 가장 마지막에 있는 setState만 적용이 된다. setState에 갱신될 상태값을 넣으면 동일한 key에 대해서는 가장 마지막 setState만 갱신됨.
- `window.addEventListener('click')` 과 같이 React에서 직접적으로 관리하지 않는 영역에서 상태변경함수를 사용할 경우엔 동기적으로 실행 → ReactDOM.unstable_batchUpdate 사용

<br>
<br>

### [***Hooks***] useEffect

- 부수 효과를 처리하기 위한 hook이다.
  - 함수 실행 시 함수 외부의 상태를 변경하는 연산을 부수 효과라고 부른다.
  - (ex API 호출, 이벤트 처리 함수를 등록하고 해제하는 것 등)
- useEffect hook의 인자는 부수효과함수와 의존성배열이다.

<br>

#### 부수효과 함수

- **부수효과 함수**는 렌더링 결과가 실제 돔에 반영된 후 비동기 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 비동기로 호출된다.
- 부수효과 함수는 오직 "함수"만 반환 가능하다.
  - 따라서 async 함수를 부수효과함수로 작성하면 에러가 발생한다.(promise객체를 반환하니까)
  - 반환되는 함수는 다음 부수효과함수가 실행되기 전 또는 컴포넌트가 unmount될 때 실행된다.
- 그러면 부수효과 함수에서 async를 어떻게 사용해야 되는가
  - 부수효과함수 안에서 async function을 선언하고 사용
  - 외부에 있는 async 함수를 가져오는 경우가 있는데, 이때는 의존성배열에 async 함수를 넣어줘야 된다.(react에서 제공하는 lint를 따르게 되면)
    - 리-렌더 마다 컴포넌트 내부에 선언된 함수들이 재생성되니까 useCallback을 사용해서 async함수를 메모이제이션해야 함
  - async를 사용하는 custom 훅

<br>

#### 의존성 배열 관리

- useEffect 훅의 두번째 매개변수로 배열을 입력하면, 배열의 값이 변경되는 경우에만 함수가 호출된다. 이 배열을 의존성 배열이라고 한다.(의존성 배열 없을 때 렌더링 이후 매번 실행)

```
1. useEffect(effect) ==> 컴포넌트가 렌더링될 때마다 호출된다.
2. useEffect(effect, []) ==> 첫 번째 렌더링 후에만 호출된다.
3. useEffect(effect, [userId]) ==> 첫 번째 렌더링 후에 호출되며, 이후에 userId가 변경될 때마다 호출된다.
```

- 의존성 배열은 최대한 비우는 것이 좋다. 혹은 없는 것이 좋다. 의존성 배열에서 실수가 많기 때문에,
  - 의존성 배열을 없애고 부수효과함수에서 분기문으로 처리하는 방식을 고려해보는 것도 좋다.
  - React에서도 이것을 인지하고 있으며 lint를 제공하고 있다.
- 부수효과함수에서 상태값이나 속성값을 사용하면 의존성 배열에 넣어주는 것이 국룰
- 의존성 배열에 들어가야 하는 값은 렌더링과 관련된 값이어야 한다. 어떤 변수의 값이 변경됐는데 컴포넌트가 다시 렌더링되지 않는다면 그 변수는 deps 배열에 넣을 필요가 없다. 전역 변수 등은 `렌더링과 관련된 값` 이 아니다.

<br>
<br>

### [***Hooks***] useRef

### [***Hooks***] useReducer

### [***Hooks***] useContext (Context API)

### [***Hooks***] useLayoutEffect

### [***Hooks***] useImperativeHandle

### [***Hooks***] useDebugValue

<br>
<br>

## **_4.React optimization_**

### [***React optimization***] React.memo

### [***React optimization***] useMemo

### [***React optimization***] useCallback

### [***React optimization***] Virtual DOM optimization

<br>
<br>

# **_Redux_**
