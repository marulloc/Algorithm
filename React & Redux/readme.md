# **_React_**

> #### 목차
>
> 1. _About React_
> 2. _Virtual DOM_
> 3. _Hooks_
> 4. _React optimization_

<br>

## **_1. About React_**

### [***About React***] UI 라이브러리 리액트

리액트는 UI "라이브러리"다.
따라서 하나의 Web APP을 완성하려면 다른 라이브러리들을 필요로 한다.

<br>

### [***About React***] SPA

<br>

### [***About React***] UI 데이터 관리

- 리액트는 **UI 데이터가 변경되면 화면을 리-렌더 한다.**<br>
  리액트에서 UI 데이터는 "속성값"과 "상태값"이다. 따라서, 속성값과 상태값이 아닌 일반 변수가 변경되면 리액트는 변경을 인지하지 못하고 화면을 리-렌더하지 않는다.

- 부모가 리-렌더 되면 자식 또한 리-렌더 된다.<br>
  부모가 리-렌더 되면 자식 컴포넌트의 속성값과 상태값이 바뀌지 않아도 자동으로 리-렌더 되는데, 이때 **React.memo**로 리-렌더를 방지하여 최적화 할 수 있다.

- 상태값이 **객체**인 경우<br>
  리액트는 **얕은 비교**를 통해 상태 변경 여부를 판단한다.
  따라서 상태가 **객체인 경우 참조값을 비교**하기 때문에, 객체(상태의 집합)의 속성(하나의 상태)이 변경되어도 똑같다고 판단하여 리-렌더를 진행하지 않는다.
  따라서, 우리는 항상 상태를 **불변 객체**로 다뤄야 한다. 불변객체로 다루면 리액트의 **얕은 비교로도 객체, 일반 변수의 상태 변경을 파악할 수 있다.**

- 속성값을 **객체 리터럴, 함수 리터럴**로 넘겨주는 경우<br>
  자식 컴포넌트의 속성값에 객체나 함수를 리터럴 형태로 넘겨주는 경우, 부모가 리-렌더 될 때, 객체나 함수가 재생성 되면서 자식들이 리-렌더 된다.
  이때 메모이제이션을 해주는 훅(**useCallback**, **useMemo**)을 사용하거나 상수로 쓰이는 객체는 컴포넌트 외부로 빼놓아 렌더링 최적화를 해야한다.

<br>

### [***About React***] 상태 변경은 "비동기 + 일괄" 처리

```jsx
const [count, setCount] = useState(0);
const onClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  console.log(count); //변경되지 않은 이전의 값을 출력함
};
```

- **비동기 처리**<br>
  만약 상태 변경에 대해 "동기 처리"를 하게 되면, 상태 변경 함수가 호출될 때마다 화면을 다시 그리는 동안 브라우저가 멈추므로 성능 이슈가 발생한다.
- **일괄 처리**<br>
  리액트는 상태 업데이트를 16ms마다 일괄로 처리하여 리-렌더를 진행한다. `setCount`를 두 번 해도, 두 번째 `setCount`는 아직 증가되지 않은 count 값을 들고 대기 queue에 들어가기 때문에 `+1`은 단 한번만 이뤄진다. queue가 존재하여 비동기와 일괄처리 되더라도 "**호출순서 === 처리순서**"가 보장된다. 만약, 상태 변경을 바로바로 한다면 상태 변경 함수가 호출될 때 마다 화면을 다시 그리므로 성능 이슈가 발생한다.

<br>

### [***About React***] 리액트의 렌더링 과정

리액트의 렌더링 단계는 다음과 같다.

1. 최초의 가상돔이 만들어진다.
2. 최초의 가상돔을 실제돔에 적용한다.
3. 상태가 변경되면, 상태가 변경된 컴포넌트의 컴포넌트 함수를 호출하여 새로운 가상돔을 생성한다.
4. 이전에 존재하던 가상돔과 새롭게 생성된 가상돔을 비교하여 변경점을 찾는다.(가상돔은 메모리에 적재되어 있다. 가상돔은 JS객체라서 가능하다.)
5. 변경점을 실제돔에 적용한다.

<br>
<br>

## **_2. Virtual DOM_**

### [***Virtual DOM***] Why?

브라우저의 엔진은 그렇게 좋은 엔진이 아니다. 화면을 갱신하는데 굉장히 오랜 시간을 소모하게 되기 때문에, 화면 갱신(실제 돔 조작)을 최소화해야 한다. 또한 실제돔을 조작하기 위해 DOM Tree를 순회해야 하는데, SPA가 만연한 세상에서 DOM Tree의 depth는 `querySelector`와 같은 함수로 매번 순회하기에 너무 깊다.

<br>

- 리액트는 가상돔을 메모리에 두고, 새로운 가상돔을 만들어 이전의 가상돔과 비교를 통해 변경된 부분만을 실제돔에 적용한다. 즉, 화면 렌더링에 있어 나름의 최적화가 되어 있다.
  > 이 가상돔의 존재가 리액트 최적화의 전부는 아니다.
  > 가상돔은 리액트가 사용하기 위한 정보가 담겨있는 **단순한 JS 객체다.** 따라서 메모리에 로드되어 있다.

<br>

- 리액트는 컴포넌트 함수 내부에서 바로 DOM을 조작할 수 있다.
  > 실제 DOM을 조작하는 것은 아니다. 가상돔을 조작하는 것이다. 그러나 결국 실제돔에 적용된다.

### [***Virtual DOM***] _Babel_ 없는 _React_

### [***Virtual DOM***] _createElement_ 와 _React Element_

### [***Virtual DOM***] _ReactDOM.render()_

### [***Virtual DOM***] _Virtual DOM_

### [***Virtual DOM***] _렌더 단계_

### [***Virtual DOM***] _커밋 단계_ (more)

### [***Virtual DOM***] _fiber_ (more)

<br>
<br>

## **_3. Hooks_**

### [***Hooks***] Hook 사용 규칙

1. 컴포넌트 내에서 hook 호출 순서는 항상 같아야 한다.
   - React가 useState 와 useEffect 가 여러 번 호출되는 중에도 Hook의 상태를 올바르게 유지할 수 있다 → React가 Hook이 호출되는 순서에 의존하여 각 useState와 useEffect를 구분하기 때문!
   - 참고: [https://ko.reactjs.org/docs/hooks-rules.html#explanation](https://ko.reactjs.org/docs/hooks-rules.html#explanation)
2. 함수형 컴포넌트나 커스텀 훅 내에서만 호출되어야 한다.

<br>
<br>

### [***Hooks***] useState

- 함수형 컴포넌트에 상태를 추가하기 위해 사용하는 Hook.
- 반환값은 [상태, 상태변경함수]
- 상태 변경은 비동기이며 일괄로 처리된다. 일괄처리 될 때, 호출 순서 === 처리 순서는 보장된다.
  - 만약 상태 변경에 대해 "동기 처리"를 하게 되면, 상태 변경 함수가 호출될 때마다 화면을 다시 그리는 동안 브라우저가 멈추므로 성능 이슈가 발생한다.
  - 일괄 처리: 리액트는 상태 업데이트를 16ms마다 일괄로 처리하여 리-렌더를 진행한다. 만약, 상태 변경을 바로바로 한다면 상태 변경 함수가 호출될 때 마다 화면을 다시 그리므로 성능 이슈가 발생한다.
- 상태 변경 코드를 동기적으로 실행하기 위해 **함수형 업데이트**를 사용하기도 한다.
  - // 최적화 & 테스트 효율성 & 동기적인 실행
- 상태값은 불변변수로 다뤄야한다.
  - 리액트는 단순비교로 상태 변경을 판단한다.
  - 만약 상태가 객체인 경우엔, 참조값을 들고있기 때문에, 상태 객체의 프로퍼티(하나의 상태)가 변경되어도 리액트는 알 수 없다.
  - 불변객체로 다루면, 참조값이 변경되기 때문에 상태값 변경을 단순비교로도 알 수 있다.
    [사이드이펙트 쪽으로도 알아봐야할 듯]
- 상탯값 변경함수와 클래스형 컴포넌트에서의 setState와의 차이점
  - setState메서드는 기존 상탯값과 새로 입력된 값을 병합한다
  - useState 훅의 상탯값 변경함수는 이전 상탯값을 덮어쓴다.
  - useState 훅은 이전 상탯값을 덮어쓰기 때문에 ...state와 같은 코드가 필요하다. 이렇게 상탯값을 하나의 객체로 관리할 때는 useReducer 훅을 사용하는 것이 좋다.

<br>

**🤔 좀더 검증이 필요한 뽀인트들**

- setState 함수는 비동기로 처리되는데 메인 프로세스 중에 호출된 모든 setState가 모두 처리되기 전에 컴포넌트가 렌더링되지는 않는다.
- 상태에 대한 동일한 key에 접근하여 값을 변경하는 setState에 대해서는 가장 마지막에 있는 setState만 적용이 된다. setState에 갱신될 상태값을 넣으면 동일한 key에 대해서는 가장 마지막 setState만 갱신됨.
- `window.addEventListener('click')` 과 같이 React에서 직접적으로 관리하지 않는 영역에서 상태변경함수를 사용할 경우엔 동기적으로 실행 → ReactDOM.unstable_batchUpdate 사용

<br>
<br>

### [***Hooks***] useEffect

- 부수 효과를 처리하기 위한 hook이다.
  - 함수 실행 시 함수 외부의 상태를 변경하는 연산을 부수 효과라고 부른다.
  - (ex API 호출, 이벤트 처리 함수를 등록하고 해제하는 것 등)
- useEffect hook의 인자는 부수효과함수와 의존성배열이다.

<br>

#### 부수효과 함수

- **부수효과 함수**는 렌더링 결과가 실제 돔에 반영된 후 비동기 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 비동기로 호출된다.
- 부수효과 함수는 오직 "함수"만 반환 가능하다.
  - 따라서 async 함수를 부수효과함수로 작성하면 에러가 발생한다.(promise객체를 반환하니까)
  - 반환되는 함수는 다음 부수효과함수가 실행되기 전 또는 컴포넌트가 unmount될 때 실행된다.
- 그러면 부수효과 함수에서 async를 어떻게 사용해야 되는가
  - 부수효과함수 안에서 async function을 선언하고 사용
  - 외부에 있는 async 함수를 가져오는 경우가 있는데, 이때는 의존성배열에 async 함수를 넣어줘야 된다.(react에서 제공하는 lint를 따르게 되면)
    - 리-렌더 마다 컴포넌트 내부에 선언된 함수들이 재생성되니까 useCallback을 사용해서 async함수를 메모이제이션해야 함
  - async를 사용하는 custom 훅

<br>

#### 의존성 배열 관리

- useEffect 훅의 두번째 매개변수로 배열을 입력하면, 배열의 값이 변경되는 경우에만 함수가 호출된다. 이 배열을 의존성 배열이라고 한다.(의존성 배열 없을 때 렌더링 이후 매번 실행)

```
1. useEffect(effect) ==> 컴포넌트가 렌더링될 때마다 호출된다.
2. useEffect(effect, []) ==> 첫 번째 렌더링 후에만 호출된다.
3. useEffect(effect, [userId]) ==> 첫 번째 렌더링 후에 호출되며, 이후에 userId가 변경될 때마다 호출된다.
```

- 의존성 배열은 최대한 비우는 것이 좋다. 혹은 없는 것이 좋다. 의존성 배열에서 실수가 많기 때문에,
  - 의존성 배열을 없애고 부수효과함수에서 분기문으로 처리하는 방식을 고려해보는 것도 좋다.
  - React에서도 이것을 인지하고 있으며 lint를 제공하고 있다.
- 부수효과함수에서 상태값이나 속성값을 사용하면 의존성 배열에 넣어주는 것이 국룰
- 의존성 배열에 들어가야 하는 값은 렌더링과 관련된 값이어야 한다. 어떤 변수의 값이 변경됐는데 컴포넌트가 다시 렌더링되지 않는다면 그 변수는 deps 배열에 넣을 필요가 없다. 전역 변수 등은 `렌더링과 관련된 값` 이 아니다.

<br>

#### 최적화를 위한 함수형 업데이트와 useEffect

의존성 배열을 비우는 것이 최선이다. 예를 들어, 외부에 선언된 비동기 함수를 사용할 때 useCallback 훅과 의존성 배열에 함수를 넣어저눈 것 보다. useEffect가 렌더링마다 실행되게 만들고 분기문으로 처리하는 것이 괜찮은 방식이다.

**함수형 업데이트로 최적화를 하는 경우는 다음과 같다.**

- 렌더링 된 후, 변경된 상태값을 통해 다시 상태값을 변경해야 하는 경우다.
- count가 바뀔 때 마다 부수효과 함수가 실행된다. onClick함수가 재 생성되고 window에 이벤트핸들러가 부착되고 해제되는 것이 반복된다.

```jsx
function Component() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    function onClick() {
      setCount(count + 1);
    }
    window.addEventListener("click", onClick);
    return () => window.removeEventListener("click", onClick);
  }, [count]);
  return null;
}
```

#### 이것을 함수형 업데이트로 최적화해보자.

```jsx
useEffect(() => {
  function onClick() {
    setCount((count) => count + 1);
  }
  window.addEventListener("click", onClick);
  return () => window.removeEventListener("click", onClick);
}, []);
```

- 상태변경 함수에 새로운 상태"값"을 주는 것이 아니라, 상태를 "어떻게" 업데이트 할지를 넘겨주는 **함수형 업데이트**
- 함수형 업데이트를 사용하면, useEffect나 useCallback에서 동작하는 횟수를 줄일 수 있다.

> useCallback 내부에 작성한 함수에도 함수형 업데이트를 통해 최적화를 할 수 있다.
> `const onIncrease = useCallback(()=> setNumber(number => number + 1), [])`
> useCallback이 mount 될 때 동작하고, 이후에는 동작 안하게 만들 수 있다.

<br>
<br>

### [***Hooks***] useRef

- DOM 요소에 직접 접근하거나, 렌더링과 관련 없는 데이터를 저장하기 위해 사용하는 hook.
- 반환값은 ref객체, 인자로는 초기값을 받는다.
  - ref 객체의 current 프로퍼티에 참조값이나 데이터를 저장한다.
  - ref 객체는 전 생애주기 동안 같은 객체를 가리킨다.
- ref 안의 값이 바뀌어도 컴포넌트가 렌더링되지 않는 점에서 주의해야 한다.

<br>

#### DOM요소에 접근하기 위해 사용할 때

- DOM 요소가 렌더링 된 후에 참조할 수 있으므로, useEffect 부수효과 함수 내에서 참조값을 사용하는 것이 보통이다.
- `useRef()`를 사용하여 Ref 객체를 만들고, 이 객체를 우리가 선택하고 싶은 DOM 에 `ref` 값으로 설정해주어야 한다. 그러면, Ref 객체의 `.current` 값은 우리가 원하는 DOM 요소를 가르키게 된다.
- 함수형 컴포넌트의 경우 ref를 그냥 사용하면, 리액트가 내부적으로 사용하게 되어 우리가 사용할 수 없다.
  - React.forwardRef 함수를 사용하면 됨.
- 클래스 컴포넌트의 경우 ref 전달하면, 해당 컴포넌트의 인스턴스를 가리킨다.
- ref 속성에 함수를 주는경우 `<Title ref={(ref) => ref && setText("asdsad")}` (🤔 함수리터럴이라 부르는 것이 맞나???)
  - Title 컴포넌트가 생성될 때 인자로, 참조값이 넘어온다.
  - Title 컴포넌트가 제거될 때 인자로 null 값이 넘어온다.
  - 사용하려면 && 연산자 잊지 말자.
- <주의> 컴포넌트나 돔 요소가 조건부 렌더링에 걸려있는 경우 Ref의 current가 없을 수 있으니, 옵셔널 체이닝을 사용하자. `titleRef.current?.메소드나 변수`

<br>

#### 렌더링에 무관한 값을 저장하는 용도로 사용할 때

- useRef가 반환하는 ref객체는 일반 js 객체로, heap 영역에 저장된다. 따라서 가비지컬렉터에 걸리지 않는 한 변수가 유지된다.
- useRef(초기화 값)은 딱 한 번 실행된다.
- 컴포넌트의 상태가 바뀌면, 컴포넌트 함수가 다시 실행되면서 함수 내부 모든 변수가 초기화된다.
- 다시 렌더링 되어도 기존에 참조하고 있던 변수들을 유지하기 위해 useRef함수를 사용한다는 것을 잊지말자.
- useRef가 반환하는 객체의 current 프로퍼티에 담긴 것은, 상태가 바껴도 컴포넌트가 리-렌더 되지 않으며
- 또한, 리-렌더가 발생해도 current의 값은 유지된다.

<br>
<br>

### [***Hooks***] useLayoutEffect

- useEffect와 비슷하지만, 호출 시점과 동작 방식이 다르다.
  - **가상돔 렌더링 결과 도출 -> 실제돔에 반영 -> 브라우저에 적용 -> useEffect "비동기"로 동작**
- useLayoutEffect는 동기적으로 호출된다.
  - **가상돔 렌더링 결과 도출 -> 실제돔에 반영 -> useLayoutEffect 동기 동작 -> 브라우저에 적용**
  - useEffect에서 화면이 업데이트 된후 useEffect 내부에서 DOM을 재조정하는 경우 "화면 깜빡임" 이슈가 발생한다. 이때 useLayoutEffect를 고려하면 된다.
  - 대신 useLayoutEffect는 동기적으로 동작하기 때문에 너무 긴 작업을 하게 되면, 완료되는 순간까지 사용자가 브라우저를 이용할 수가 없다.

<br>
<br>

### [***Hooks***] useImperativeHandle

- 클래스형 컴포넌트에서는 자식 컴포넌트 인스턴스의 메소드나 변수에 접근이 가능하다. 자식 컴포넌트의 메소드나 변수에 접근하는 것은 "의존성" 이슈 때문에 지양해야 하지만, 해야될 때가 있다.
- 함수형 컴포넌트에서도 자식 컴포넌트의 메소드나 변수에 접근하고자 만든 훅이 useImperativeHandle이다.
- useRef가 반환한 객체를 자식 컴포넌트에 넘겨주고,
- 자식 컴포넌트에서는 받은 Ref 객체를, useImperativeHandle 훅을 이용해 맵핑해주면 된다.

```jsx
function Child({childRef}){
  const someMethod = () => {..}
  const someVar = 100
  useImperativeHandle(childRef, () => ({
    someMethod,
    someVar
  }))
}
```

<br>
<br>

### [***Hooks***] useDebugValue

- 커스텀 훅의 내부상태를 자세히 표시하기 위해 사용한다.
- 브라우저의 디버깅 툴에서 확인 가능하다.

<br>
<br>

### [***Hooks***] useReducer &

### [***Hooks***] useContext (Context API)

<br>
<br>

## **_4.React optimization_**

### [***React optimization***] React.memo

### [***React optimization***] useMemo

### [***React optimization***] useCallback

### [***React optimization***] Virtual DOM optimization

<br>
<br>

# **_Redux_**
